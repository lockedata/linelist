% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clean_variable_spelling.R
\name{clean_variable_spelling}
\alias{clean_variable_spelling}
\title{Check and clean spelling or codes of multiple variables in a data frame}
\usage{
clean_variable_spelling(x = data.frame(), wordlists = list(),
  spelling_vars = 3, sort_by = NULL, classes = NULL, warn = FALSE)
}
\arguments{
\item{x}{a \code{data.frame}}

\item{wordlists}{a data frame or named list of data frames with at least two
columns defining the word list to be used. If this is a data frame, a third
column must be present to split the wordlists by column in \code{x} (see
\code{spelling_vars}).}

\item{spelling_vars}{character or integer. If \code{wordlists} is a data frame,
then this column in defines the columns in \code{x} corresponding to each
section of the \code{wordlists} data frame. This defaults to \code{3}, indicating the
third column is to be used.}

\item{sort_by}{a character the column to be used for sorting the values in
each data frame. If the incoming variables are factors, this determines how
the resulting factors will be sorted.}

\item{classes}{a vector of class definitions for each of the columns. If this
is not provided, the classes will be read from the columns themselves.
Practically, this is used in \code{\link[=clean_data]{clean_data()}} to mark columns as protected.}

\item{warn}{if \code{TRUE}, warnings and errors from \code{\link[=clean_spelling]{clean_spelling()}} will be
shown as a single warning. Defaults to \code{FALSE}, which shows nothing.}
}
\value{
a data frame with re-defined data based on the dictionary
}
\description{
This function allows you to clean your data according to
pre-defined rules encapsulated in either a data frame or list of data frames.
It has application for addressing mis-spellings and recoding variables (e.g.
from electronic survey data).
}
\details{
By default, this applies the function \code{\link[=clean_spelling]{clean_spelling()}} to all
columns specified by the column names listed in \code{spelling_vars}, or, if a
global dictionary is used, this includes all \code{character} and \code{factor}
columns as well.

\subsection{Global wordlists}{

A global wordlist is a set of definitions applied to all valid columns of \code{x}
indiscriminantly.
\itemize{
\item \strong{.global spelling_var}: If you want to apply a set of definitions to all
valid columns in addition to specified columns, then you can include a
\code{.global} group in the \code{spelling_var} column of your \code{wordlists} data
frame. This is useful for setting up a dictionary of common spelling
errors. \emph{NOTE: specific variable definitions will override global
defintions.} For example: if you have a column for cardinal directions
and a definiton for \code{N = North}, then the global variable \code{N = no} will
not override that. See Example.
\item \strong{\code{spelling_vars = NULL}}: If you want your data frame to be applied to
all character/factor columns indiscriminantly, then setting
\code{spelling_vars = NULL} will use that wordlist globally.
}

}
}
\note{
This function will only parse character and factor columns to protect
numeric and Date columns from conversion to character.
}
\examples{

# Set up wordlist ------------------------------------------------ 

yesno  <- c("y", "n", "u", ".missing")
dyesno <- c("Yes", "No", "Unknown", "Missing")

treated  <- c(0:1, ".missing")
dtreated <- c("Yes", "No", "Missing")

facility  <- c(1:10, ".default") # define a .default key
dfacility <- c(sprintf("Facility \%s", format(1:10)), "Unknown")

age_group  <- c(0, 10, 20, 30, 40, 50)
dage_group <- c("0-9", "10-19", "20-29", "30-39", "40-49", "50+")

result <- c("neg", "negatif", "pos", "positif")
dresult <- c("Negative", "Negative", "Positive", "Positive")

wordlist <- data.frame(
  options = c(yesno, treated, facility, age_group, result),
  values  = c(dyesno, dtreated, dfacility, dage_group, dresult),
  grp = rep(c("readmission", "treated", "facility", "age_group",
              ".regex ^result_"),
            c(4, 3, 11, 6, 4)),
  orders  = c(1:4, 1:3, 1:11, 1:6, 1:4),
  stringsAsFactors = FALSE
)

# Assigning global values ----------------------------------------

global_words <- data.frame(
  options = c("y", "n", "u", "unk", "oui", ".missing"),
  values  = c("yes", "no", "unknown", "unknown", "yes", "missing"),
  grp     = rep(".global", 6),
  orders  = rep(Inf, 6),
  stringsAsFactors = FALSE
)

wordlist <- rbind(wordlist, global_words, stringsAsFactors = FALSE)

# Generate example data ------------------------------------------
dat <- data.frame(
  # these have been defined
  readmission = sample(yesno, 50, replace = TRUE),
  treated = sample(treated, 50, replace = TRUE),
  facility = sample(c(facility[-11], LETTERS[1:3]), 50, replace = TRUE),
  age_group = sample(age_group, 50, replace = TRUE),
  # global values will catch these
  has_symptoms = sample(c(yesno, "unk", "oui"), 50, replace = TRUE),
  followup = sample(c(yesno, "unk", "oui"), 50, replace = TRUE),
  result_01 = sample(c(result, "unk"), 50, replace = TRUE),
  result_02 = sample(c(result, "unk"), 50, replace = TRUE),
  result_03 = sample(c(result, "unk"), 50, replace = TRUE),
  stringsAsFactors = FALSE
)

missing_data <- dat == ".missing"
dat[missing_data] <- sample(c("", NA), sum(missing_data), prob = c(0.1, 0.9), replace = TRUE)

# Clean spelling based on wordlist ------------------------------ 

wordlist # show the wordlist
head(dat) # show the data

res1 <- clean_variable_spelling(dat,
                                wordlists = wordlist,
                                spelling_vars = "grp")
head(res1)

# You can ensure the order of the factors are correct by specifying 
# a column that defines order.

dat[] <- lapply(dat, as.factor)
as.list(head(dat))
res2 <- clean_variable_spelling(dat, 
                                wordlists = wordlist, 
                                spelling_vars = "grp", 
                                sort_by = "orders")
head(res2)
as.list(head(res2))

}
\seealso{
\code{\link[=clean_spelling]{clean_spelling()}}, which this function wraps.
}
\author{
Zhian N. Kamvar
}

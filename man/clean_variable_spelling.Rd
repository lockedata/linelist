% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clean_variable_spelling.R
\name{clean_variable_spelling}
\alias{clean_variable_spelling}
\title{Check and clean spelling or codes of multiple variables in a data frame}
\usage{
clean_variable_spelling(
  x = data.frame(),
  wordlists = list(),
  from = 1,
  to = 2,
  spelling_vars = 3,
  sort_by = NULL,
  classes = NULL,
  warn = FALSE
)
}
\arguments{
\item{x}{a \code{data.frame}}

\item{wordlists}{a data frame or named list of data frames with at least two
columns defining the word list to be used. If this is a data frame, a third
column must be present to split the wordlists by column in \code{x} (see
\code{spelling_vars}).}

\item{from}{a column name or position defining words or keys to be replaced}

\item{to}{a column name or position defining replacement values}

\item{spelling_vars}{character or integer. If \code{wordlists} is a data frame,
then this column in defines the columns in \code{x} corresponding to each
section of the \code{wordlists} data frame. This defaults to \code{3}, indicating the
third column is to be used.}

\item{sort_by}{a character the column to be used for sorting the values in
each data frame. If the incoming variables are factors, this determines how
the resulting factors will be sorted.}

\item{classes}{a vector of class definitions for each of the columns. If this
is not provided, the classes will be read from the columns themselves.
Practically, this is used in \code{\link[=clean_data]{clean_data()}} to mark columns as protected.}

\item{warn}{if \code{TRUE}, warnings and errors from \code{\link[=clean_spelling]{clean_spelling()}} will be
shown as a single warning. Defaults to \code{FALSE}, which shows nothing.}
}
\value{
a data frame with re-defined data based on the dictionary
}
\description{
This function allows you to clean your data according to
pre-defined rules encapsulated in either a data frame or list of data frames.
It has application for addressing mis-spellings and recoding variables (e.g.
from electronic survey data).
}
\details{
By default, this applies the function \code{\link[=clean_spelling]{clean_spelling()}} to all
columns specified by the column names listed in \code{spelling_vars}, or, if a
global dictionary is used, this includes all \code{character} and \code{factor}
columns as well.

\subsection{spelling_vars}{

Spelling variables within \code{wordlists} represent keys that you want to match
to column names in \code{x} (the data set). These are expected to match exactly
with the exception of two reserved keywords that starts with a full stop:
\itemize{
\item \code{.regex [pattern]}: any column whose name is matched by \verb{[pattern]}. The
\verb{[pattern]} should be an unquoted, valid, PERL-flavored regular expression.
\item \code{.global}: any column (see Section \emph{Global wordlists})
}

}

\subsection{Global wordlists}{

A global wordlist is a set of definitions applied to all valid columns of \code{x}
indiscriminantly.
\itemize{
\item \strong{.global spelling_var}: If you want to apply a set of definitions to all
valid columns in addition to specified columns, then you can include a
\code{.global} group in the \code{spelling_var} column of your \code{wordlists} data
frame. This is useful for setting up a dictionary of common spelling
errors. \emph{NOTE: specific variable definitions will override global
defintions.} For example: if you have a column for cardinal directions
and a definiton for \code{N = North}, then the global variable \code{N = no} will
not override that. See Example.
\item \strong{\code{spelling_vars = NULL}}: If you want your data frame to be applied to
all character/factor columns indiscriminantly, then setting
\code{spelling_vars = NULL} will use that wordlist globally.
}

}
}
\note{
This function will only parse character and factor columns to protect
numeric and Date columns from conversion to character.
}
\examples{

# Read in dictionary and coded date examples --------------------

wordlist <- read.csv(linelist_example("spelling-dictionary.csv"), 
                     stringsAsFactors = FALSE)
dat      <- read.csv(linelist_example("coded-data.csv"), 
                     stringsAsFactors = FALSE)
dat$date <- as.Date(dat$date)

# Clean spelling based on wordlist ------------------------------ 

wordlist # show the wordlist
head(dat) # show the data

res1 <- clean_variable_spelling(dat,
                                wordlists = wordlist,
                                from = "options",
                                to = "values",
                                spelling_vars = "grp")
head(res1)

# You can ensure the order of the factors are correct by specifying 
# a column that defines order.

dat[] <- lapply(dat, as.factor)
as.list(head(dat))
res2 <- clean_variable_spelling(dat, 
                                wordlists = wordlist, 
                                from = "options",
                                to = "values",
                                spelling_vars = "grp", 
                                sort_by = "orders")
head(res2)
as.list(head(res2))

}
\seealso{
\code{\link[=clean_spelling]{clean_spelling()}}, which this function wraps.
}
\author{
Zhian N. Kamvar

Patrick Barks
}
